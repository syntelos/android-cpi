
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;

import fv3.font.GlyphVector;
import fv3.font.HersheyFont;
import fv3.font.HersheyGlyph;
import fv3.math.VertexArray;

/**
 * Generate named font to target C++ header file.
 */
public class font {

    public final static String CamelCase(String in){
        StringBuilder string = new StringBuilder();
        final char[] cary = in.toCharArray();
        final int len = cary.length;
        boolean upcase = true;
        for (int cc = 0; cc < len; cc++){
            char ch = cary[cc];
            if (Character.isIdentifierIgnorable(ch)){
                upcase = true;
            }
            else if (upcase){
                upcase = false;
                string.append(Character.toUpperCase(ch));
            }
            else {
                string.append(ch);
            }
        }
        return string.toString();
    }
    public final static String BaseName(String in){
        int idx = in.lastIndexOf('.');
        if (0 < idx){
            return in.substring(0,idx);
        }
        else
            throw new IllegalArgumentException(in);
    }
    public final static float Fix(HersheyFont font){

        final int count = font.getLength();
        /*
         * Measure glyph common origin
         */
        float minX = Float.MAX_VALUE;

        for (int cc = 0; cc < count; cc++){

            HersheyGlyph glyph = font.get(cc);

            float[] vertices = glyph.array();

            final int nv3 = vertices.length;

            if (0 < nv3){

                for (int x = 0; (x+2) < nv3; x+=3){

                    minX = Math.min(minX,vertices[x]);
                }
            }
        }
        /*
         * Translate glyphs to common origin
         * 
         * Measure common width
         */
        float maxX = Float.MIN_VALUE;

        if (0.0 < minX){
            for (int cc = 0; cc < count; cc++){

                HersheyGlyph glyph = font.get(cc);

                float[] vertices = glyph.array();

                final int nv3 = vertices.length;

                if (0 < nv3){

                    for (int x = 0; (x+2) < nv3; x+=3){

                        vertices[x] -= minX;

                        maxX = Math.max(maxX,vertices[x]);
                    }
                }
            }
        }
        else {
            throw new IllegalStateException(String.valueOf(minX));
        }

        return maxX;
    }
    public final static void main(String[] argv){
        if (1 == argv.length){

            final File file = new File(argv[0]);
            final String fn = file.getName();

            final String cn = BaseName(fn);

            try {
                HersheyFont font = new HersheyFont.Futural();
                
                final float EM = Fix(font);

                final int count = font.getLength();
                final int term = (count-1);

                /*
                 * Generate file
                 */
                PrintStream out = new PrintStream(new FileOutputStream(file));
                try {
                    out.println("/*");
                    out.println(" * Copyright (C) 2014, John Pritchard.  All rights reserved.");
                    out.println(" */");
                    out.println("package com.johnpritchard.cpi;");
                    out.println();
                    out.println("import android.graphics.Path;");
                    out.println();
                    out.println("/**");
                    out.println(" * Generated by 'tools/font'.");
                    out.println(" */");
                    out.printf ("public class %s {%n",cn);
                    out.println();
                    out.printf ("    public final static float Em = %2.4ff;%n",EM);
                    out.println();
                    out.printf ("    public final static float Ascent = %2.4ff;%n",font.getAscent());
                    out.println();
                    out.printf ("    public final static float Descent = %2.4ff;%n",font.getDescent());
                    out.println();
                    out.printf ("    public final static float Leading = %2.4ff;%n",font.getLeading());
                    out.println();
                    out.println("    public final static Path Apply(char c, Path p){");
                    out.println("        p.reset();");
                    out.println("        try {");
                    out.println("            final float[] glyph = GlyphSet[c - 0x20];");
                    out.println("            final int count = glyph.length;");
                    out.println();
                    out.println("            boolean once = true;");
                    out.println();
                    out.println("            for (int cc = 6; cc < count; ){");
                    out.println();
                    out.println("                float x = glyph[cc++];");
                    out.println("                float y = glyph[cc++];");
                    out.println();
                    out.println("                if (once){");
                    out.println("                    once = false;");
                    out.println("                    p.moveTo(x,y);");
                    out.println("                 }");
                    out.println("                 else {");
                    out.println("                    p.lineTo(x,y);");
                    out.println("                 }");
                    out.println("             }");
                    out.println("        }");
                    out.println("        catch (RuntimeException exc){");
                    out.println("        }");
                    out.println("        return p;");
                    out.println("    }");
                    out.println();
                    out.println("    /**");
                    out.println("     * Array of glyphs, each having the following structure.");
                    out.println("     * <pre>");
                    out.println("     *   minX, midX, maxX, ");
                    out.println("     *   minY, midY, maxY, ");
                    out.println("     *   vertices-XY* ");
                    out.println("     * </pre>");
                    out.println("     * ");
                    out.println("     * A glyph may be dereferenced by index (char-' ').");
                    out.println("     */");
                    out.println("    private final static float[][] GlyphSet = {");

                    /*
                     * char value = (' ' + cc)
                     */
                    for (int cc = 0; cc < count; cc++){

                        HersheyGlyph glyph = font.get(cc);

                        final float[] vertices = glyph.array();

                        final int nv3 = vertices.length;

                        float minX = Float.MAX_VALUE;
                        float maxX = Float.MIN_VALUE;
                        float minY = Float.MAX_VALUE;
                        float maxY = Float.MIN_VALUE;

                        if (0 < nv3){

                            for (int x = 0, y = 1, z = 2; z < nv3; x+=3,y+=3,z+=3){

                                float fx = vertices[x];
                                float fy = vertices[y];

                                minX = Math.min(minX,fx);
                                maxX = Math.max(maxX,fx);

                                minY = Math.min(minY,fy);
                                maxY = Math.max(maxY,fy);
                            }
                        }
                        else {
                            minX = 0f;
                            maxX = font.getEm();
                            minY = 0f;
                            maxY = 0f;
                        }

                        float midX = (minX + maxX)/2f;
                        float midY = (minY + maxY)/2f;

                        out.printf ("        {%n");
                        out.printf ("            % 2.2ff, % 2.2ff, % 2.2ff,%n",minX,midX,maxX);
                        out.printf ("            % 2.2ff, % 2.2ff, % 2.2ff,%n",minY,midY,maxY);

                        if (0 < nv3){
                            /*
                             * Emit vertices
                             */
                            for (int x = 0, y = 1, z = 2; z < nv3; x+=3,y+=3,z+=3){

                                float fx = vertices[x];
                                /*
                                 * flip vertical
                                 */
                                float fy = ZP(maxY-vertices[y]);

                                out.printf ("            % 2.2ff, % 2.2ff,%n",fx,fy);
                            }
                        }

                        if (cc < term){
                            out.printf ("        },%n");
                        }
                        else {
                            out.printf ("        }%n");
                        }
                    }

                    out.println();
                    out.println("    };");
                    out.println();
                    out.println("}");
                }
                finally {
                    out.close();
                }
            }
            catch (IOException not_found){
                not_found.printStackTrace();

                System.err.printf("%nError: unrecognized font, or unable to write file '%s'.%n",file);

                System.exit(1);
            }
        }
        else {
            System.err.printf("Usage%n\tfont <tgt.java>%nDescription%n\tGenerate header and source files for font.%n");
            System.exit(1);
        }
    }

    private final static float ZP(float v){
        if (0.0f < v)
            return v;
        else
            return 0.0f;
    }
}
